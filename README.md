# colafence

## 对目前工作的认识

1. 在当前机器下(Linux cola-virtual-machine 6.5.0-21-generic #21~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Fri Feb  9 13:32:52 UTC 2 x86_64 x86_64 x86_64 GNU/Linux)制作一个内存分配器(感觉要写理清 linux 的内存分配，心里大致有个数)

目前是决定以不更改任何系统代码的方式以动态链接开箱即用的方式实现

2. 实现在用户申请空间时一个周期使用一次我制作的内存分配器,这通过动态共享库来包装 malloc 来实现

3. 分析（不做那么长的计划 2.29）

## 进度

## 参考资料

## 目前可以想到的问题

1. 我们要观测的是用户态应用，kfence 的原理就是在内存分配阶段周期性的使用自己的内存分配器分配特殊的块，我该如何让用户态的 malloc 使用我的内存分配器呢？

在Linux，如果你将一个动态库文件的路径设置在环境变量LD_PRELOAD中，这个库文件会优先被加载。利用这个特性可以保证我们一会在shell中运行程序时使用我们实现的malloc(),free(),calloc()和realloc()。

这个问题解决了（https://stackoverflow.com/questions/17803456/an-alternative-for-the-deprecated-malloc-hook-functionality-of-glibc）

2. 后面可能还要考虑多线程

3. 最终要返回的是物理地址，使用用户态内存的话返回的恐怕会是虚拟地址

这个问题我想错了，对于一个用户进程来说，物理地址似乎是没有意义的

4. 目前没找到能不够可以获取 4M 大小内存空间的方法

不打算让页大小变小，打算让页数量变少一些

5. kfence 中通过 toggle_allocation_gate 周期性的开启一个延时任务

6. 模块只执行一个作为内存分配器的工作，延时要放在动态共享库中

7. kfence 的目的似乎是防止申请的这些内存又被拿去做别的

8. 我不能让每个程序执行时都重新初始化一遍我的内存池和时钟等，方法是使用守护进程或系统服务

我把这个东西想的太高了，现在看来，类似 GDB 那样的使用方式可能更加合适，开销也可以控制到一个可以接受的地方
